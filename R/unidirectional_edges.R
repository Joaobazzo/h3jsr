#' check if H3 addresses are neighbours
#'
#' This function checks whether two H3 addresses share an edge.
#' @param origin Character; 15-character address generated by H3. A vector of
#'   addresses can also be supplied.
#' @param destination Character; 15-character address generated by H3. A vector
#'   of addresses can also be supplied.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return Logical; TRUE if neighbours.
#' @note
#' \itemize{
#'   \item{The number of addresses supplied to origin and
#' destination must be equal.}
#'   \item{This function will always return false if
#' the addresses are of different resolutions.}
#'  }
#' @examples
#' # Are the following addresses neighbours?
#' h3_are_neighbours(origin = '86be8d12fffffff', destination = '86be8d127ffffff')
#'
#' @import V8
#' @export
#'
h3_are_neighbours <- function(origin = NULL, destination = NULL, simple = TRUE) {

  if(any(h3_is_valid(c(origin, destination))) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin), is.null(destination))) {
    stop('Missing required input.')
  }

  if(length(origin) != length(destination)) {
    stop('Uneven origin and destination addresses supplied.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(origin, destination,
                                     stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_neighbours = h3.h3IndexesAreNeighbors(evalThis[i].origin, evalThis[i].destination);
            };')

  if(simple == TRUE) {
    sesh$get('evalThis')$h3_neighbours
  } else {
    sesh$get('evalThis')
  }

}

#' get a unidirectional edge
#'
#' Get an H3 address representing a unidirectional edge for a given origin and
#' destination.
#' @inheritParams h3_are_neighbours
#' @return By default, character vector of edges.
#' @note \itemize{ \item{The number of addresses supplied to origin and
#' destination must be equal.} }
#' @examples
#' # Are the following addresses neighbours?
#' h3_get_udedge(origin = '86be8d12fffffff', destination = '86be8d127ffffff')
#'
#' @import V8
#' @export
#'
h3_get_udedge <- function(origin = NULL, destination = NULL, simple = TRUE) {

  if(any(h3_is_valid(c(origin, destination))) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin), is.null(destination))) {
    stop('Missing required input.')
  }

  if(length(origin) != length(destination)) {
    stop('Uneven origin and destination addresses supplied.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(origin, destination,
                                     stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_udedge = h3.getH3UnidirectionalEdge(evalThis[i].origin, evalThis[i].destination);
            };')

  if(simple == TRUE) {
    sesh$get('evalThis')$h3_udedge
  } else {
    sesh$get('evalThis')
  }

  }

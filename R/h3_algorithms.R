#' get parent H3 address
#'
#' This function returns the parent of a particular H3 address at the requested
#' resolution.
#' @param h3_address Character; 15-character address generated by H3.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # What is the parent of this address at resolution 6?
#' h3_to_parent(h3_address = '8abe8d12acaffff', res = 6)
#' @import V8
#' @export
#'
h3_to_parent <- function(h3_address = NULL, res = NULL, simple = TRUE) {

  # Establish js interface
  sesh <- V8::v8()

  # load required js packages from bundle
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # frame up for JSON conversion
  eval_this <- data.frame(h3_address, 'h3_res' = res, stringsAsFactors = FALSE)

  # send df to js env as JSON
  sesh$assign('evalThis', eval_this)

  # do the thing
  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_parent = h3.h3ToParent(evalThis[i].h3_address, evalThis[i].h3_res);
            };')

  # retrieve the result
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_parent
  } else {
    sesh$get('evalThis')
  }

}

#' get child H3 addresses
#'
#' This function returns the children of a particular H3 address at the
#' requested resolution.
#' @inheritParams h3_to_parent
#' @return By default, a list of length(h3_address). Each list element contains
#'   a vector of H3 addresses.
#' @note The number of addresses returned for each request is `7 ^ (parent_res -
#'   child_res)`, so jumping three levels will return 343 addresses per request.
#'   This can cause memory issues with larger requests.
#' @examples
#' # What are the children of this resolution 6 address at resolution 8?
#' h3_to_children(h3_address = '86be8d12fffffff', res = 8)
#' @import V8
#' @export
#'
h3_to_children <- function(h3_address = NULL, res = NULL, simple = TRUE) {

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, 'h3_res' = res, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToChildren(evalThis[0].h3_address, evalThis[0].res)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_children = h3.h3ToChildren(evalThis[i].h3_address, evalThis[i].h3_res);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_children
  } else {
    sesh$get('evalThis')
    }

}

#' get nearby H3 addresses
#'
#' This function returns all the H3 addresses within a specified number of
#' steps from the address supplied.
#' @param h3_address Character; 15-character address generated by H3.
#' @param ring_size Character; number of steps away from the central address.
#'   Defaults to 1.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a list of length(h3_address). Each list element contains
#'   a character vector of H3 addresses.
#' @note While the parent function name `kRing` may imply returning a donut of
#'   addresses, it actually returns a patch centered on the input. The number of
#'   addresses returned for each input address conforms to the [centered
#'   hexagonal number
#'   sequence](https://en.wikipedia.org/wiki/Centered_hexagonal_number), so at
#'   `ring_size = 5`, 91 addresses are returned. The first address returned is
#'   the input address, the rest follow in a spiral anticlockwise order.
#' @examples
#' # What are all the neighbours of this address within two steps?
#' h3_get_kring(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
h3_get_kring <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.kRing(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_kring = h3.kRing(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_kring
  } else {
    sesh$get('evalThis')
  }

}

#' get nearby H3 addresses separated by distance
#'
#' This function returns all the H3 addresses within a specified number of steps
#' from the address supplied, listed by step.
#' @inheritParams h3_get_kring
#' @return By default, a list of length(h3_address). Each list element contains
#'   a list of `length(ring_size + 1)`. Each of those lists contains a character
#'   vector of H3 addresses belonging to that step away from the input address.
#' @note In total, the number of addresses returned for each input address
#'   conforms to the [centered hexagonal number
#'   sequence](https://en.wikipedia.org/wiki/Centered_hexagonal_number), so at
#'   `ring_size = 5`, 91 addresses are returned. Addresses are returned in
#'   separate lists, one for each step.
#' @examples
#' # What are the nested neighbours of this address within two steps?
#' h3_get_kring_list(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
h3_get_kring_list <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.kRingDistances(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_kringd = h3.kRingDistances(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_kringd
  } else {
    sesh$get('evalThis')
  }

}

#' get a donut of H3 addresses
#'
#' This function returns all the H3 addresses at the specified step from the
#' address supplied.
#' @inheritParams h3_get_kring
#' @return By default, a list of length(h3_address). Each list element contains
#'   a character vector of H3 addresses belonging to that step away from the
#'   input address.
#' @note In total, the number of addresses returned for each input address is
#'   `ring_size \* 6`.
#' @examples
#' # What are the neighbours of this address at step 2?
#' h3_get_ring(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
h3_get_ring <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.hexRing(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_ring = h3.hexRing(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_ring
  } else {
    sesh$get('evalThis')
  }

}

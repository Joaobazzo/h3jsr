#' get parent H3 address
#'
#' This function returns the parent of a particular H3 address at the requested
#' resolution.
#' @param h3_address Character; 15-character address generated by H3.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # What is the parent of this address at resolution 6?
#' get_parent(h3_address = '8abe8d12acaffff', res = 6)
#' @import V8
#' @export
#'
get_parent <- function(h3_address = NULL, res = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }
  if(!any(res %in% seq(0, 15))) {
    stop('Please provide a valid H3 resolution. Allowable values are 0-15 inclusive.')
  }

  # Establish js interface
  sesh <- V8::v8()

  # load required js packages from bundle
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # frame up for JSON conversion
  eval_this <- data.frame(h3_address, 'h3_res' = res, stringsAsFactors = FALSE)

  # send df to js env as JSON
  sesh$assign('evalThis', eval_this)

  # do the thing
  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_parent = h3.h3ToParent(evalThis[i].h3_address, evalThis[i].h3_res);
            };')

  # retrieve the result
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_parent
  } else {
    sesh$get('evalThis')
  }

}

#' get child H3 addresses
#'
#' This function returns the children of a particular H3 address at the
#' requested resolution.
#' @inheritParams get_parent
#' @return By default, a list of length(h3_address). Each list element contains
#'   a vector of H3 addresses.
#' @note The number of addresses returned for each request is `7 ^ (parent_res -
#'   child_res)`, so jumping three levels will return 343 addresses per request.
#'   This can cause memory issues with larger requests.
#' @examples
#' # What are the children of this resolution 6 address at resolution 8?
#' get_children(h3_address = '86be8d12fffffff', res = 8)
#' @import V8
#' @export
#'
get_children <- function(h3_address = NULL, res = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }
  if(!any(res %in% seq(0, 15))) {
    stop('Please provide a valid H3 resolution. Allowable values are 0-15 inclusive.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, 'h3_res' = res, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToChildren(evalThis[0].h3_address, evalThis[0].res)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_children = h3.h3ToChildren(evalThis[i].h3_address, evalThis[i].h3_res);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_children
  } else {
    sesh$get('evalThis')
    }

}

#' Get nearby H3 addresses
#'
#' This function returns all the H3 addresses within a specified number of
#' steps from the address supplied.
#' @param h3_address Character; 15-character address generated by H3.
#' @param ring_size Character; number of steps away from the central address.
#'   Defaults to 1.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a list of length(h3_address). Each list element contains
#'   a character vector of H3 addresses.
#' @note While the parent function name `kring` may imply returning a donut of
#'   addresses, it actually returns a patch centered on the input. The number of
#'   addresses returned for each input address conforms to the [centered
#'   hexagonal number
#'   sequence](https://en.wikipedia.org/wiki/Centered_hexagonal_number), so at
#'   `ring_size = 5`, 91 addresses are returned. The first address returned is
#'   the input address, the rest follow in a spiral anticlockwise order.
#' @examples
#' # What are all the neighbours of this address within two steps?
#' get_kring(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
get_kring <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.kRing(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_kring = h3.kRing(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_kring
  } else {
    sesh$get('evalThis')
  }

}

#' Get nearby H3 addresses separated by distance
#'
#' This function returns all the H3 addresses within a specified number of steps
#' from the address supplied, grouped by step.
#' @inheritParams get_kring
#' @return By default, a list of length(h3_address). Each list element contains
#'   a list of `length(ring_size + 1)`. Each of those lists contains a character
#'   vector of H3 addresses belonging to that step away from the input address.
#' @note In total, the number of addresses returned for each input address
#'   conforms to the [centered hexagonal number
#'   sequence](https://en.wikipedia.org/wiki/Centered_hexagonal_number), so at
#'   `ring_size = 5`, 91 addresses are returned. Addresses are returned in
#'   separate lists, one for each step.
#' @examples
#' # What are the nested neighbours of this address within two steps?
#' get_kring_list(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
get_kring_list <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.kRingDistances(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_kringd = h3.kRingDistances(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_kringd
  } else {
    sesh$get('evalThis')
  }

}

#' Get a donut of H3 addresses
#'
#' This function returns all the H3 addresses at the specified step from the
#' address supplied.
#' @inheritParams get_kring
#' @return By default, a list of length(h3_address). Each list element contains
#'   a character vector of H3 addresses belonging to that step away from the
#'   input address.
#' @note In total, the number of addresses returned for each input address is
#'   `ring_size \* 6`.
#' @examples
#' # What are the neighbours of this address at step 2?
#' get_ring(h3_address = '86be8d12fffffff', ring_size = 2)
#' @import V8
#' @export
#'
get_ring <- function(h3_address = NULL, ring_size = 1, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, ring_size, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.hexRing(evalThis[0].h3_address, evalThis[0].ring_size)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_ring = h3.hexRing(evalThis[i].h3_address, evalThis[i].ring_size);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_ring
  } else {
    sesh$get('evalThis')
  }

}

#' Get H3 addresses within a polygon
#'
#' This function returns all the H3 addresses within the supplied polygon
#' geometry.
#' @param geometry `sf` object of type 'POLYGON'.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return a vector of outputs or an sf object
#'   containing both inputs and outputs.
#' @return By default, a list of length(h3_address). Each list element contains
#'   a character vector of H3 addresses belonging to that polygon. A result of
#'   NA indicates that no H3 addresses of the chosen resolution are centered
#'   over the polygon.
#' @note This function will be slow with a large number of polygons, and/or
#'   polygons that are large relative to the hexagon area at the chosen
#'   resolution.
#' @examples
#' # Which level 5 H3 addresses have centers inside County Ashe, NC?
#' nc <- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
#' nc1 <- nc[1, ]
#' nc1 <- sf::st_cast(nc1, 'POLYGON')
#' fillers <- polyfill(geometry = nc1, res = 5)
#' @import V8
#' @importFrom sf st_as_sf st_crs st_geometry st_geometry_type st_sf
#'   st_transform
#' @importFrom geojsonsf sfc_geojson
#' @export
#'
polyfill <- function(geometry = NULL, res = NULL, simple = TRUE) {

  if(!any(res %in% seq(0, 15))) {
    stop('Please provide a valid H3 resolution. Allowable values are 0-15 inclusive.')
  }

  # welcome to the future, sp'ers *cackles*
  #
  # (I failed at UseMethod ;_;)
  if(class(geometry)[[1]] != 'sf') {
    stop('Please provide an sf polygon object')
  }

  # multipolygon support some other time... maybe
  if(any(sf::st_geometry_type(geometry) != 'POLYGON')) {
    stop('At least one of the supplied features is not of type POLYGON, please amend and try again.')
  }

  if(sf::st_crs(geometry)$epsg != 4326) {
    warning('Data has been transformed to EPSG:4326.')
    geometry <- sf::st_transform(geometry, 4326)
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('res', res)

  # make geoJSON
  eval_geom <- geojsonsf::sfc_geojson(st_geometry(geometry))

  # can only send one polygon thru at a time, possible bottleneck
  results <- lapply(eval_geom, function(gm) {
    sesh$eval(paste0('var evalGeom = ', gm, ';'))
    sesh$eval('var out = h3.polyfill(evalGeom.coordinates, res, true);')
    out <- sesh$get('out')
    if(length(out) == 0) { NA_character_ } else { out }
  })

  if(simple == TRUE) {
    results
  } else {
    geometry$h3_polyfillers <- results
    sf::st_sf(geometry)
  }
}

#' Get geometry for a set of H3 addresses
#'
#' This function returns geometry associated with a set of H3 addresses, as a
#' single `sfc_MULTIPOLYGON`.
#' @param h3_addresses Character vector or list of 15-character addresses
#'   generated by H3.
#' @param simple Logical; whether to return an `sfc_MULTIPOLYGON` or an `sf`
#'   object including the input addresses.
#' @return By default, object of type `sfc_MULTIPOLYGON` of length 1.
#' @note The geometry returned by this function will not be valid where the
#'   addresses supplied overlap at the same resolution. The main use case for
#'   this function appears to be visualising the outputs of `polyfill()` and
#'   `compact()`.
#' @examples
#' # Give me the outline of the hexagons around Brisbane Town Hall at
#' # resolution 10
#' bth <- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
#' bth_10 <- point_to_h3(bth, res = 10)
#' bth_patch <- get_kring(h3_address = bth_10, ring_size = 2)
#' bth_patch_sf <- set_to_multipolygon(bth_patch)
#'
#' @import V8
#' @importFrom sf st_is_valid st_sf
#' @importFrom geojsonsf geojson_sf
#' @export
#'
set_to_multipolygon <- function(h3_addresses = NULL, simple = TRUE) {

  # in case a list output from another function is supplied
  h3_addresses <- unlist(h3_addresses, use.names = FALSE)

  if(any(is_valid(h3_addresses)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  # handle single address supplied, although doing that would be silly
  if(length(h3_addresses) == 1) {
    sesh$assign('evalThis', list(h3_addresses))
  } else {
    sesh$assign('evalThis', h3_addresses)
  }
  # sesh$eval('console.log(evalThis.length);')
  sesh$eval('var geometry = h3.h3SetToMultiPolygon(evalThis, formatAsGeoJson = true);')
  # sesh$eval('console.log(JSON.stringify(geometry));')
  # Output still isn't proper geoJSON, just the .coordinates. Where input
  # addresses overlap at the same resolution, invalid polygons are output.
  # However, overlaps at different resolutions are fine.
  sesh$eval('var geom_out = JSON.stringify({type: "MultiPolygon", coordinates: geometry});')
  geometry <- geojsonsf::geojson_sfc(sesh$get('geom_out'))

  # graceful fail if geom is bad
  if(any(is.na(sf::st_is_valid(geometry)))) {
    stop('An invalid geometry was returned from this set of addresses.')
  }

  if(simple == TRUE) {
    geometry
  } else {
    out <- sf::st_sf(geometry)
    out$h3_addresses <- list(h3_addresses)
    sf::st_sf(out) # blerg
  }
}

#' Compact H3 addresses
#'
#' This function compacts a set of hexagons of the same resolution into a set of
#' hexagons across multiple levels that represents the same area.
#' @param h3_addresses Character vector or list of 15-character addresses
#'   generated by H3 at a single resolution, generally the output of
#'   \code{\link[h3jsr:polyfill]{polyfill}}.
#' @param simple Logical; whether to return a vector of outputs or a list object
#'   containing both inputs and outputs.
#' @return A list of H3 addresses with multiple resolutions. The minimum
#'   resolution of the output list matches the resolution of the input list.
#' @examples \dontrun{
#' # Give me a compacted representation of County Ashe, NC
#' nc <- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
#' nc1 <- nc[1, ]
#' nc1 <- sf::st_cast(nc1, 'POLYGON')
#' fillers <- polyfill(geometry = nc1, res = 6)
#' compacted <- compact(fillers)
#' }
#' @import V8
#' @export
#'
compact <- function(h3_addresses = NULL, simple = TRUE) {

  h3_addresses <- unlist(h3_addresses, use.names = FALSE)

  if(any(is_valid(h3_addresses)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  # handle single address supplied, although doing that would be silly
  if(length(h3_addresses) == 1) {
    sesh$assign('evalThis', list(h3_addresses))
  } else {
    sesh$assign('evalThis', h3_addresses)
  }
  # sesh$eval('console.log(evalThis.length);')
  sesh$eval('var comp = h3.compact(evalThis);')
  # sesh$eval('console.log(JSON.stringify(comp));')

  if(simple == TRUE) {
    sesh$get('comp')
  } else {
    list('input_addresses' = h3_addresses,
         'compacted_addresses' = unlist(sesh$get('comp')))
  }
}

#' Uncompact H3 addresses
#'
#' This function uncompacts a compacted set of H3 addresses to addresses of the
#' target resolution.
#' @param h3_addresses Character vector or list of 15-character addresses
#'   generated by H3.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return a vector of outputs or a list object
#'   containing both inputs and outputs.
#' @return A list of H3 addresses of the chosen resolution.
#' @examples \dontrun{
#' # Give me a compacted representation of County Ashe, NC
#' nc <- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
#' nc1 <- nc[1, ]
#' nc1 <- sf::st_cast(nc1, 'POLYGON')
#' fillers <- polyfill(geometry = nc1, res = 6)
#' compacted <- compact(fillers)
#' # uncompact to resolution 7
#' uncompacted <- uncompact(compacted, res = 7)
#' }
#' @import V8
#' @export
#'
uncompact <- function(h3_addresses = NULL, res = NULL, simple = TRUE) {

  h3_addresses <- unlist(h3_addresses, use.names = FALSE)

  if(any(is_valid(h3_addresses)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(!any(res %in% seq(0, 15))) {
    stop('Please provide a valid H3 resolution. Allowable values are 0-15 inclusive.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('res', res)
  # handle single address supplied
  if(length(h3_addresses) == 1) {
    sesh$assign('evalThis', list(h3_addresses))
  } else {
    sesh$assign('evalThis', h3_addresses)
  }
  # sesh$eval('console.log(evalThis.length);')
  sesh$eval('var comp = h3.uncompact(evalThis, res);')
  # sesh$eval('console.log(JSON.stringify(comp));')

  if(simple == TRUE) {
    sesh$get('comp')
  } else {
    list('input_addresses' = h3_addresses,
         'uncompacted_addresses' = unlist(sesh$get('comp')))
  }
}

#' Convert H3 addresses to a line
#'
#' Return line geometry for a sequence of H3 addresses in WGS84 coordinates.
#' @param input Character; 15-character address generated by H3, or a vector or
#'   list of same, or a data frame where the last column is a list-column of H3
#'   addresses (usually the output of
#'   \code{\link[h3jsr:grid_path]{h3jsr::grid_path()}}.
#' @param simple Logical; whether to return an `sfc_LINESTRING` object or an `sf`
#'   data frame containing both inputs and outputs.
#' @return By default, an `sfc_LINESTRING` object of `length(input)`. If an
#'   appropriately formatted data frame is supplied, an `sf` data frame
#'   containing input attributes and geometry.
#' @import V8
#' @examples
#' # What is the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_hex_10 <- h3_to_polygon(input = '8abe8d12acaffff')
#'
#' # Give me a some nearby hexagons
#' hex_sample <- get_kring_list('8abe8d12acaffff', 4)[[1]][[4]][seq(1,18,3)]
#' hex_sample_polys <- h3_to_polygon(hex_sample)
#'
#' # find connecting paths
#' paths <- grid_path(rep('8abe8d12acaffff', 6), hex_sample)
#'
#' # make lines
#' lines <- h3_to_line(paths)
#'
#'\dontrun{
#' plot(hex_sample_polys, reset = FALSE)
#' plot(brisbane_hex_10, add = TRUE)
#' plot(lines, col = 'red', add = TRUE)
#' }
#'
#' @importFrom sf st_linestring st_sfc st_sf
#' @export
#'
h3_to_line <- function(input = NULL, simple = TRUE) {

  conv <- if(is(input, 'data.frame')) {
    input[[ncol(input)]]
  } else {
    input
  }

  # cast addresses to points
  points <- if(typeof(conv) == 'list') {
    lapply(conv, h3_to_point, simple = TRUE)
  } else {
    h3_to_point(conv, simple = TRUE)
  }

  # make lines from point sequences
  hex_lines <- if(is(points, 'list')) {
   lns <- lapply(points, function(l) {
      interleaved <- rbind(l[1:(length(l) - 1)], l[2:length(l)])
      matrified <- lapply(interleaved, as.matrix, ncol = 2, byrow = T)
      rbound <- do.call('rbind', matrified)
      st_linestring(rbound)
    })
   st_sfc(lns, crs = 4326)
  } else {
    interleaved <- rbind(points[1:(length(points) - 1)], points[2:length(points)])
    matrified <- lapply(interleaved, as.matrix, ncol = 2, byrow = T)
    rbound <- do.call('rbind', matrified)
    lined <- st_linestring(rbound)
    st_sfc(lined, crs = 4326)
  }

  if(simple == TRUE) {
    hex_lines
  } else {
    if(is(input, 'data.frame')) {
      return( sf::st_sf(input, 'geometry' = hex_lines))
    }

    if(is(input, 'list')) {
      return(sf::st_sf("input" = I(input), 'geometry' = hex_lines))
    }

    # leftover case is a simple vector of addresses
    sf::st_sf("input" = I(list(input)), 'geometry' = hex_lines)
    # note is(I(list()), 'list') = FALSE, use typeof() instead
  }

}

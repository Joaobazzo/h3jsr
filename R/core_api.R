#' check H3 address
#'
#' This function checks whether an H3 address is valid.
#' @param h3_address Character; 15-character address generated by H3.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address valid?
#' h3_is_valid(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
h3_is_valid <- function(h3_address = NULL, simple = TRUE) {

  # Establish js interface
  sesh <- V8::v8()

  # load required js packages from bundle
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # frame up for JSON conversion
  eval_this <- data.frame(h3_address, stringsAsFactors = FALSE)

  # send df to js env as JSON
  sesh$assign('evalThis', eval_this)

  # do the thing
  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_valid = h3.h3IsValid(evalThis[i].h3_address);
            };')

  # retrieve the result
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_valid
  } else {
    sesh$get('evalThis')
  }

}

#' check if H3 address is a pentagon
#'
#' This function checks whether a H3 address refers to one of the pentagons
#' that occur at icosahedron corners.
#' @inheritParams h3_is_valid
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address a pentagon?
#' h3_is_pentagon(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
h3_is_pentagon <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsPentagon(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_pentagon = h3.h3IsPentagon(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_pentagon
  } else {
    sesh$get('evalThis')
  }
}

#' check if H3 address is a in a Class III resolution
#'
#' This function checks whether a H3 address is in a Class III resolution
#' (rotated versus the icosahedron and subject to shape distortion adding extra
#' points on icosahedron edges, making them not true hexagons).
#' @inheritParams h3_is_valid
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address Class III?
#' h3_is_rc3(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
h3_is_rc3 <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsResClassIII(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_rc3 = h3.h3IsResClassIII(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_rc3
  } else {
    sesh$get('evalThis')
  }

}

#' get the base cell of an H3 address
#'
#' This function returns the number of the base (Level 1) cell for an H3
#' address.
#' @inheritParams h3_is_valid
#' @return By default, an integer vector of length(h3_address), ranging from
#'   0 to 121.
#' @examples
#' # What is Brisbane Town Hall's base cell number?
#' h3_get_base_cell(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
h3_get_base_cell <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3GetBaseCell(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_base_cell = h3.h3GetBaseCell(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_base_cell
  } else {
    sesh$get('evalThis')
  }

}

#' get the resolution of an H3 address
#'
#' This function returns an H3 address' resolution level.
#' @inheritParams h3_is_valid
##' @return By default, an integer vector of length(h3_address), ranging from
#'   1 to 15.
#' @examples
#' # What is the H3 resolution of this address?
#' h3_get_res(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
h3_get_res <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3GetResolution(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
          evalThis[i].h3_res = h3.h3GetResolution(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_res
  } else {
    sesh$get('evalThis')
  }
}

#' Convert point location to H3 address
#'
#' This function takes a latitude and longitude in WGS84 and returns a H3
#' address at the chosen resolution.
#' @param lon Number; Longitude in decimal degrees and WGS84 datum.
#' @param lat Number; Latitude in decimal degrees and WGS84 datum
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outpus.
#' @return By default, a character vector of H3 addresses.
#' @note You can supply multiple coordinates and resolutions as vectors, but
#'   they must be recyclable against each other. It is safest to provide many
#'   points and one resolution, or one point and many resolutions.
#' @import V8
#' @examples
#' # where is the Brisbane Town Hall at resolution 15?
#' brisbane <- geo_to_h3(lon = 153.023503, lat = -27.468920, res = 15)
#'
#' # where is it at multiple resolutions?
#' brisbane_all <- geo_to_h3(lon = 153.023503, lat = -27.468920,
#'                           res = seq(15), simple = FALSE)
#' @export
#'
geo_to_h3 <- function(lon = NULL, lat = NULL, res = NULL, simple = TRUE) {

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # failproof
  if(!any(res %in% seq(15))) {
    return('Please provide a valid H3 resolution. Allowable values are 1-15 inclusive.')
  }

  eval_this <- data.frame('X' = lon, 'Y' = lat, 'h3_res' = res,
                          stringsAsFactors = FALSE)

  # NB digits = NA is for toJSON(), to prevent numerical precision loss
  sesh$assign('evalThis', eval_this, digits = NA)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.geoToH3(evalThis[0].Y, evalThis[0].X, evalThis[0].res));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_address = h3.geoToH3(evalThis[i].Y, evalThis[i].X, evalThis[i].h3_res);
            };')

  # NB no need to specify digits on return trip
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_address
  } else {
    sesh$get('evalThis')
  }

}

#' Convert H3 address to point location
#'
#' This function takes a H3 address and returns the coordinates of the center of
#' that H3 hexagon in WGS84.
#' @inheritParams h3_is_valid
#' @return By default, a two-column matrix containing X and Y coordinates in
#'   EPSG:WGS84.
#' @import V8
#' @examples
#' # Where is the center of the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_10 <- h3_to_geo(h3_address = '8abe8d12acaffff')
#'
#' @export
#'
h3_to_geo <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToGeo(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_x = h3.h3ToGeo(evalThis[i].h3_address)[1];
            evalThis[i].h3_y = h3.h3ToGeo(evalThis[i].h3_address)[0];
            };')
  if(simple == TRUE) {
    as.matrix(sesh$get('evalThis')[, c(2,3)])
  } else {
    sesh$get('evalThis')
  }

}

#' get the bounding points of a H3 address
#'
#' This function takes a H3 address and returns the coordinates of its bounding
#' shape (usually a hexagon) in WGS84.
#' @inheritParams h3_is_valid
#' @return By default, a list of matrices suitable for use with
#'   `sf::st_polygon()`.
#' @import V8
#' @examples
#' # What is the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_hex_10 <- h3_to_geo_boundary(h3_address = '8abe8d12acaffff')
#'
#' @export
#'
h3_to_geo_boundary <- function(h3_address = NULL, simple = TRUE) {

  if(any(h3_is_valid(h3_address, simple = TRUE)) == FALSE) {
    return('Please provide a valid H3 address.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  eval_this <- data.frame(h3_address, stringsAsFactors = FALSE)
  sesh$assign('evalThis', eval_this, digits = NA)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToGeoBoundary(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_hex = h3.h3ToGeoBoundary(evalThis[i].h3_address);
            };')

  coords <- sesh$get('evalThis')

  # tidy up and convert to mat (goal is an easy cast to sf)
  coords$h3_hex <- lapply(coords$h3_hex, function(hex) {
    hex <- rbind(hex, hex[1,])
    hex[, c(2,1)]
  })

  if(simple == TRUE) {
    coords$h3_hex
  } else {
    coords
  }
}

#microbenchmark::microbenchmark(
#  'A' = {
#    hex <- coords$h3_hex[[1]]
#    rbind(hex, hex[1,])
#    hex[, c(2,1)]
#  },
#  'B' = {
#    hex <- coords$h3_hex[[1]]
#    matrix(c(hex[ ,2], hex[1, 2], hex[, 1], hex[1, 1]),
#           ncol = 2, byrow = FALSE)
#  }, times = 10000)


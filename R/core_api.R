#' check H3 address
#'
#' This function checks whether an H3 address is valid.
#' @param h3_address Character; 15-character address generated by H3.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address valid?
#' is_valid(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
is_valid <- function(h3_address = NULL, simple = TRUE) {

  # Establish js interface
  sesh <- V8::v8()

  # load required js packages from bundle
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # frame up for JSON conversion
  eval_this <- data.frame(h3_address, stringsAsFactors = FALSE)

  # send df to js env as JSON
  sesh$assign('evalThis', eval_this)

  # do the thing
  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsValid(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_valid = h3.h3IsValid(evalThis[i].h3_address);
            };')

  # retrieve the result
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_valid
  } else {
    sesh$get('evalThis')
  }

}

#' check if H3 address is a pentagon
#'
#' This function checks whether a H3 address refers to one of the pentagons
#' that occur at icosahedron corners.
#' @inheritParams is_valid
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address a pentagon?
#' is_pentagon(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
is_pentagon <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsPentagon(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_pentagon = h3.h3IsPentagon(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_pentagon
  } else {
    sesh$get('evalThis')
  }
}

#' check if H3 address is a in a Class III resolution
#'
#' This function checks whether a H3 address is in a Class III resolution
#' (rotated versus the icosahedron and subject to shape distortion adding extra
#' points on icosahedron edges, making them not true hexagons).
#' @inheritParams is_valid
#' @return By default, a logical vector of length(h3_address).
#' @examples
#' # is the following address Class III?
#' is_rc3(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
is_rc3 <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3IsResClassIII(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_rc3 = h3.h3IsResClassIII(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_rc3
  } else {
    sesh$get('evalThis')
  }

}

#' get the base cell of an H3 address
#'
#' This function returns the number of the base (Level 1) cell for an H3
#' address.
#' @inheritParams is_valid
#' @return By default, an integer vector of length(h3_address), ranging from
#'   0 to 121.
#' @examples
#' # What is Brisbane Town Hall's base cell number?
#' get_base_cell(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
get_base_cell <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3GetBaseCell(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_base_cell = h3.h3GetBaseCell(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_base_cell
  } else {
    sesh$get('evalThis')
  }

}

#' get the resolution of an H3 address
#'
#' This function returns an H3 address' resolution level.
#' @inheritParams is_valid
##' @return By default, an integer vector of length(h3_address), ranging from
#'   1 to 15.
#' @examples
#' # What is the H3 resolution of this address?
#' get_res(h3_address = '8abe8d12acaffff')
#' @import V8
#' @export
#'
get_res <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3GetResolution(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
          evalThis[i].h3_res = h3.h3GetResolution(evalThis[i].h3_address);
            };')
  if(simple == TRUE) {
    sesh$get('evalThis')$h3_res
  } else {
    sesh$get('evalThis')
  }
}

#' Convert point location to H3 address
#'
#' This function takes point location data and returns a H3 address for each
#' point at the chosen resolution(s).
#' @param points object of class sfc_POINT. If crs is not WGS84, it will be
#'   converted.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @param simple Logical; whether to return only outputs, or an `sf` object
#'   containing both inputs and outputs.
#' @return By default, a character vector of H3 addresses. if `simple = FALSE`,
#'   the input sf object is returned with new columns, one for each requested
#'   resolution. If `simple = TRUE` and multiple resolutions are requested, a
#'   data.frame is returned.
#' @note While multiple resolutions can be requested for multiple points, be
#'   aware of the memory demand on large datasets.
#' @import V8
#' @importFrom methods is
#' @importFrom sf st_crs st_geometry st_sf
#' @importFrom tidyr spread
#' @examples
#' # where is the Brisbane Town Hall at resolution 15?
#' bth <- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
#' bth_15 <- point_to_h3(bth, res = 15)
#'
#' # where is it at several resolutions?
#' bth_many <- point_to_h3(bth, res = seq(10, 15), simple = FALSE)
#' @export
#'
point_to_h3 <- function(points = NULL, res = NULL, simple = TRUE) {

  if(!methods::is(sf::st_geometry(points), 'sfc_POINT')) {
    stop('Please supply an sfc_POINT object')
  }

  if(!any(res %in% seq(0, 15))) {
    stop('Please provide a valid H3 resolution. Allowable values are 0-15 inclusive.')
  }

  if(sf::st_crs(points)$epsg != 4326) {
    message('Data has been transformed to EPSG:4326.')
    points <- sf::st_transform(points, 4326)
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))

  # There are some serious shenanigans from here on to deal with multiple points
  # and multiple resolutions, just roll with it
  eval_this <- data.frame('X' = rep(sapply(sf::st_geometry(points), function(pt) pt[1]),
                                    length(res)),
                          'Y' = rep(sapply(sf::st_geometry(points), function(pt) pt[2]),
                                    length(res)),
                          'h3_res' = rep(res, each = length(sf::st_geometry(points))),
                          stringsAsFactors = FALSE)

  sesh$assign('evalThis', eval_this, digits = NA)
  # sesh$eval('console.log(evalThis[0].X);')
  # sesh$eval('console.log(JSON.stringify(h3.geoToH3(evalThis[0].Y, evalThis[0].X, evalThis[0].res));')
  sesh$eval('var h3_address = [];
            for (var i = 0; i < evalThis.length; i++) {
              h3_address[i] = h3.geoToH3(evalThis[i].Y, evalThis[i].X, evalThis[i].h3_res);
            };')

  # get data back. If length(res != 1), divide up outputs properly
  addys <- data.frame('n' = seq(length(sf::st_geometry(points))),
                      'res' = rep(res, each = length(sf::st_geometry(points))),
                      'h3_address' = sesh$get('h3_address'),
                      stringsAsFactors = FALSE)
  addys <- tidyr::spread(addys, 'res', 'h3_address')
  addys$n <- NULL
  names(addys) <- paste0('h3_resolution_', names(addys))

  if (simple == TRUE) {
    if (length(res) == 1) {
      unlist(addys, use.names = FALSE)
    } else {
      addys
    }
  } else {
    sf::st_sf(data.frame(addys, points), stringsAsFactors = FALSE)
  }
}

#' Convert H3 address to point location
#'
#' This function takes a H3 address and returns the coordinates of the center of
#' that H3 hexagon in WGS84.
#' @inheritParams is_valid
#' @return By default, an `sfc_POINT` object of `length(h3_address)`.
#'   EPSG:WGS84.
#' @import V8
#' @examples
#' # Where is the center of the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_10 <- h3_to_point(h3_address = '8abe8d12acaffff')
#'
#' @export
#'
h3_to_point <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToGeo(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_resolution = h3.h3GetResolution(evalThis[i].h3_address);
            evalThis[i].geometry = h3.h3ToGeo(evalThis[i].h3_address);
            };')

  pts <- sesh$get('evalThis')
  pts$geometry <- lapply(pts$geometry, function(x) {
    # the coords come back as y,x ;_;
    sf::st_point(c(x[2], x[1]))
  })
  pts$geometry <- sf::st_sfc(pts$geometry, crs = 4326)

  if(simple == TRUE) {
    pts$geometry
  } else {
    sf::st_sf(pts)
  }

}

#' Get the boundary of an H3 address
#'
#' This function takes an H3 address and returns its bounding shape (usually a
#' hexagon) in WGS84.
#' @inheritParams is_valid
#' @return By default, an `sfc_POLYGON` object of `length(h3_address)`.
#' @import V8
#' @examples
#' # What is the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_hex_10 <- h3_to_polygon(h3_address = '8abe8d12acaffff')
#'
#' # Give me some of the hexes over Brisbane Town Hall as an sf object
#' bth <- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
#' bth_addys <- unlist(point_to_h3(bth, res = seq(10, 15)), use.names = FALSE)
#' bth_hexes <- h3_to_polygon(h3_address = bth_addys)
#' plot(bth_hexes, axes = TRUE)
#' @importFrom sf st_polygon st_sfc st_sf
#' @export
#'
h3_to_polygon <- function(h3_address = NULL, simple = TRUE) {

  if(any(is_valid(h3_address)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  sesh <- V8::v8()
  sesh$source(system.file('js', 'h3js_bundle.js', package = 'h3jsr'))
  sesh$assign('evalThis', data.frame(h3_address, stringsAsFactors = FALSE),
              digits = NA)

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.h3ToGeoBoundary(evalThis[0].h3_address)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].h3_resolution = h3.h3GetResolution(evalThis[i].h3_address);
            evalThis[i].geometry = h3.h3ToGeoBoundary(evalThis[i].h3_address, formatAsGeoJson = true);
            };')

  hexes <- sesh$get('evalThis')

  # spatialise
  hexes$geometry <- lapply(hexes$geometry, function(hex) {
    sf::st_polygon(list(hex))
  })

  hexes$geometry <- sf::st_sfc(hexes$geometry, crs = 4326)

  if(simple == TRUE) {
    hexes$geometry
  } else {
   sf::st_sf(hexes, stringsAsFactors = FALSE)
  }
}

#' find a path between H3 addresses
#'
#' This function finds a minimum-steps path between two H3 addresses of the same
#' resolution.
#' @param origin Character; 15-character address generated by H3. A vector of
#'   addresses can also be supplied.
#' @param destination Character; 15-character address generated by H3. A vector
#'   of addresses can also be supplied.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return A list of H3 addresses if simple = TRUE, an sf LINESTRING if not.
#' @note
#' \itemize{
#'   \item{At present, this function accepts a single origin and destination
#'   address.}
#'   \item{Multiple minimum-step pathways exist between any two hexagons; this
#'   function will pick one at random.}
#'  }
#' @examples
#' # Draw a path between Brisbane and Sydney at resolution 6
#' BNE_SYD <- min_path(origin = '86be8d127ffffff',
#'                     destination = '86be0e35fffffff', simple = FALSE)
#'
#' @import V8
#' @importFrom sf st_cast st_sf
#' @export
#'
min_path <- function(origin = NULL, destination = NULL, simple = TRUE) {

  if(any(is_valid(c(origin, destination))) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin), is.null(destination))) {
    stop('Missing required input.')
  }

  # 1. Check if hexes are same res - can't path if not
  if(get_res(origin) != get_res(destination)) {
    stop('Origin and Destination are not the same resolution - no path can be calculated.')
  }

  # 2. check if neighbours - if so, path is origin-destination
  if(are_neighbours(origin, destination)) {
    message('Origin and Destination are neighbours.')
    if(simple == TRUE) {
      return(list(c(origin, destination)))
    } else {
      out <- h3_to_point(c(origin, destination))
      out <- sf::st_sf(out)
      out <- dplyr::summarise(out, do_union = FALSE)
      out <- sf::st_cast(out, 'LINESTRING')
      out$path <- list(c(origin, destination))
      out$do_union <- NULL
      out <- sf::st_sf(out)
      out
    }
  }

  # 3. Find how far apart they are
  steps <- grid_distance(origin, destination)
  if(steps == -1) {
    message('h3jsr::grid_distance() has failed for these two points.')
  }

  # 4. get path addresses
  # note that this just returns origin-destination if grid_distance returns -1
  # and I definitely did that on purpose >_>
  path <- vector('list', length = steps + 1)
  path[[1]] <- origin
  x <- 2
  while(x <= length(path)) {
    nbs <- data.frame('nbs' = unlist(get_ring(path[[x - 1]], ring_size = 1)),
                      stringsAsFactors = FALSE)
    nbs$dists <- grid_distance(nbs$nbs, rep(destination, dim(nbs)[1]))
    nbs <- nbs[which(nbs$dists == min(nbs$dists)), ]
    path[[x]] <- base::sample(nbs$nbs, size = 1) # randomise
    x <- x + 1
  }

  # 5. return path with optional line geometry
  if(simple == TRUE) {
    return(list(c(unlist(path), destination)))
  } else {
    out <- h3_to_point(c(unlist(path), destination))
    out <- sf::st_sf(out)
    out <- dplyr::summarise(out, do_union = FALSE)
    out <- sf::st_cast(out, 'LINESTRING')
    out$path <- list(c(unlist(path), destination))
    out$do_union <- NULL
    out <- sf::st_sf(out)
  }

}

#' Use H3 to find nearest neighbours
#'
#' This function finds the nearest neighbour for a given set of spatial points.
#' @param locations sf POINT data frame with >1 rows.
#' @param res Integer; Desired H3 resolution. See
#'   https://uber.github.io/h3/#/documentation/core-library/resolution-table for
#'   allowable values and related dimensions.
#' @return The input object with duplicated columns holding nearest neighbour
#'   attributes, along with a distance column and a secondary geometry column
#'   containing the nearest neighbour location. The additional columns
#'   are signified with naming convention '*_nn'.
#' @note The true nearest neighbour for any point should always be one of the
#'   points with the shortest \code{\link[h3jsr:grid_distance]{grid_distance}}
#'   from the origin, or at most, grid_distance + 2 if the origin is close to a
#'   hex boundary. Where more than one point is a candidate for nearest
#'   neighbour, \code{\link[sf:st_distance]{st_distance}} is used to pick the
#'   closest point, so results may not be truly accurate unless the input
#'   dataset has been projected using an appropriate distance-preserving
#'   coordinate transformation. This function will probably not be accurate at
#'   continental scales.
#' @examples \dontrun{
#' # Find the nearest neighbours for spData::cycle_hire()
#' data(cycle_hire, package = 'spData')
#' # UTM projection should give accurate enough distances at this extent
#' cycle_hire <- sf::st_transform(cycle_hire, 32630)
#' # ~10 seconds on a mid-range 2018 laptop:
#' cycle_hire_nn <- nearest_neighbour(locations = cycle_hire, res = 11)
#'
#' # check results against spatstat::nncross(), which incidentally is a lot
#' faster...
#' st_as_ppp <- function(x = NULL) {
#'   ecks <- sapply(seq.int(length(x$geometry)), function(y) {
#'     x$geometry[[y]][1]
#'   })
#'   why <- sapply(seq.int(length(x$geometry)), function(y) {
#'     x$geometry[[y]][2]
#'   })
#'   o_win <- spatstat::owin(range(ecks), range(why))
#'   spatstat::ppp(ecks, why, window = o_win)
#' }
#'
#' cycle_ppp     <- st_as_ppp(cycle_hire)
#' cycle_nncross <- spatstat::nncross(cycle_ppp, cycle_ppp, k = 2)
#'
#' # above says point #1's nearest neighbour is the point at row 167
#' cycle_hire_nn$geometry_nn[[1]] == cycle_hire_nn$geometry[[167]]
#'
#' # and that they're ~200m apart
#' cycle_hire_nn$distance_nn[1]
#' cycle_nncross$dist.2[1]
#' }
#'
#' @import V8
#' @importFrom purrr flatten map map_int
#' @importFrom sf st_crs st_distance st_geometry st_sfc
#' @export
#'
nearest_neighbour <- function(locations = NULL, res = NULL) {

  # 1. Assign an H3 address to each point at the nominated resolution.
  locations$h3 <-
    suppressMessages(point_to_h3(locations, res = res, simple = TRUE))

  # 2. set up a step holder
  locations$step <- NA_integer_

  # 3. Handle points where nearest is (probably) within the same hex
  dupe_addys <- locations$h3[which(duplicated(locations$h3))]
  locations$step[which(locations$h3 %in% dupe_addys)] <- 0L

  # 4. Determine the minimum steps to a nearby point
  iter <- 1L
  while(sum(is.na(locations$step)) > 0) {
    test_these <- locations[which(is.na(locations$step)), ]
    test_these$check <- h3jsr::get_ring(test_these$h3, ring_size = iter)
    test_these$step <- purrr::map_int(test_these$check, function(y) {
      ads <- locations$h3[which(locations$h3 %in% y) ]
      if(any(!is.na(ads))) { iter } else { NA_integer_ }
    })
    locations$step[which(is.na(locations$step))] <- test_these$step
    iter <- iter + 1L
  }

  # 5. Use get_ring() addresses within a given distance that contain a
  # potentially nearest point. Note that the true nearest point can be up to
  # $step + 2 hexes away. This is a quirk of interaction between the local hex
  # grid in use and the relative point locations.
  check_0 <- h3jsr::get_ring(locations$h3, ring_size = locations$step)
  check_1 <- h3jsr::get_ring(locations$h3, ring_size = locations$step + 1)
  check_2 <- h3jsr::get_ring(locations$h3, ring_size = locations$step + 2)
  check <- purrr::map(seq.int(dim(locations)[1]), function(x) {
    c(check_0[[x]], check_1[[x]], check_2[[x]])
    })
  locations$near <- purrr::map(check, function(y) {
    locations$h3[which(locations$h3 %in% unlist(y)) ]
    })
  loc_list <- split(locations, seq.int(dim(locations)[1]))

  nbr_geoms <- purrr::map(loc_list, function(pt) {
    get_pts <- locations[which(locations$h3 %in% unlist(pt$near)), ]
    get_pts$distance <- sf::st_distance(pt, get_pts, by_element = TRUE)
    if(pt$step == 0L) { # filter self
      get_pts <- get_pts[which(as.numeric(get_pts$distance) > 0), ]
    }
    if(dim(get_pts)[1] > 1) {
      get_pts <- get_pts[which(get_pts$distance == min(get_pts$distance)), ]
    } else {
      get_pts
    }})
  nbr_geoms <- do.call('rbind', nbr_geoms)

  # tidy up and join to input, return multi-geom object
  nbr_geoms$h3     <- NULL
  nbr_geoms$step   <- NULL
  nbr_geoms$near   <- NULL
  names(nbr_geoms) <- paste0(names(nbr_geoms), '_nn')
  attr(nbr_geoms, 'sf_column') <-
    paste0(attr(nbr_geoms, 'sf_column'), '_nn') # >_>
  locations$h3     <- NULL
  locations$step   <- NULL
  locations$near   <- NULL
  locations        <- cbind(locations, nbr_geoms)
  locations
}

#' find a path between H3 addresses
#'
#' This function finds a minimum-steps path between two H3 addresses of the same
#' resolution.
#' @param origin Character; 15-character address generated by H3. A vector of
#'   addresses can also be supplied.
#' @param destination Character; 15-character address generated by H3. A vector
#'   of addresses can also be supplied.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return A list of H3 addresses if simple = TRUE, an sf LINESTRING if not.
#' @note
#' \itemize{
#'   \item{The number of addresses supplied to origin and
#' destination must be equal.}
#'   \item{Multiple minimum-step pathways exist between any two hexagons; this
#'   function will pick one at random.}
#'  }
#' @examples
#' # Draw a path between Brisbane and Sydney at resolution 6
#' min_path(origin = '86be8d127ffffff', destination = '86be0e35fffffff', simple = FALSE)
#'
#' @import V8
#' @import sf
#' @export
#'
min_path <- function(origin = NULL, destination = NULL, simple = TRUE) {

  if(any(is_valid(c(origin, destination))) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin), is.null(destination))) {
    stop('Missing required input.')
  }

  # 1. Check if hexes are same res - can't path if not
  if(get_res(origin) != get_res(destination)) {
    stop('Origin and Destination are not the same resolution - no path can be calculated.')
  }

  # 2. check if neighbours - if so, path is origin-destination
  if(are_neighbours(origin, destination)) {
    message('Origin and Destination are neighbours.')
    if(simple == TRUE) {
      return(list(c(origin, destination)))
    } else {
      out <- h3_to_point(c(origin, destination))
      out <- sf::st_sf(out)
      out <- dplyr::summarise(out, do_union = FALSE)
      out <- sf::st_cast(out, 'LINESTRING')
      out$path <- list(c(origin, destination))
      out$do_union <- NULL
      out <- sf::st_sf(out)
      out
    }
  }

  # 3. Find how far apart they are
  steps <- grid_distance(origin, destination)
  if(steps == -1) {
    message('h3jsr::grid_distance() has failed for these two points.')
  }

  # 4. get path addresses
  # note that this just returns origin-destination if grid_distance returns -1
  # and I definitely did that on purpose >_>
  path <- vector('list', length = steps + 1)
  path[[1]] <- origin
  x <- 2
  while(x <= length(path)) {
    nbs <- data.frame('nbs' = unlist(get_ring(path[[x - 1]], ring_size = 1)),
                      stringsAsFactors = FALSE)
    nbs$dists <- grid_distance(nbs$nbs, rep(destination, nrow(nbs)))
    nbs <- nbs[which(nbs$dists == min(nbs$dists)), ]
    path[[x]] <- base::sample(nbs$nbs, size = 1) # randomise
    x <- x + 1
  }

  # 5. return path with optional line geometry
  if(simple == TRUE) {
    return(list(c(unlist(path), destination)))
  } else {
    out <- h3_to_point(c(unlist(path), destination))
    out <- sf::st_sf(out)
    out <- dplyr::summarise(out, do_union = FALSE)
    out <- sf::st_cast(out, 'LINESTRING')
    out$path <- list(c(unlist(path), destination))
    out$do_union <- NULL
    out <- sf::st_sf(out)
  }

}


#' Get local i, j coordinates
#'
#' This function defines local i, j coordinates for a H3 destination address
#' relative to an H3 origin address.
#' @param origin Character; 15-character address generated by H3. A vector of
#'   addresses can also be supplied.
#' @param destination Character; 15-character address generated by H3. A vector
#'   of addresses can also be supplied.
#' @param simple Logical; whether to include an unprojected sfc_POINT geometry
#'   column in the output object.
#' @return If `simple = TRUE`, a matrix where each row contains the local i, j
#'   coordinates for the supplied destination addresses. If not, an `sf` object
#'   with origin and destination attributes, point geometry of the destinations,
#'   and an undefined coordinate reference system.
#' @note
#' \itemize{
#'   \item{The number of addresses supplied to origin and
#' destination must be equal.}
#'   \item{The coordinate space used by this function may have deleted regions
#'   or warping due to pentagonal distortion.}
#'   \item{Coordinates are only comparable if they come from the same origin
#'   index.}
#'   \item{Failure may occur if the index is too far away from the origin or if
#'   the index is on the other side of a pentagon.}
#'   \item{This function is experimental, and its output is not guaranteed to be
#'   compatible across different versions of H3.}
#'  }
#' @examples
#' # Get local coordinates for a nearby hexagon
#' get_local_ij(origin = '86be8d12fffffff', destination = '86be8d127ffffff')
#'
#' # Get local coordinates for a donut of nearby addresses
#' destinations <- get_ring(h3_address = '86be8d12fffffff', ring_size = 2)
#' local_coords <- get_local_ij(origin = rep('86be8d12fffffff', length(destinations[[1]])),
#'                              destination = destinations[[1]],
#'                              simple = FALSE)
#'
#' plot(local_coords['destination'], pch = 19) # note origin is (0,0)
#'
#' @import V8
#' @export
#'
get_local_ij <- function(origin = NULL, destination = NULL, simple = TRUE) {

  if(any(is_valid(c(origin, destination))) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin), is.null(destination))) {
    stop('Missing required input.')
  }

  if(length(origin) != length(destination)) {
    stop('Uneven origin and destination addresses supplied.')
  }

  sesh$assign('evalThis', data.frame(origin, destination,
                                     stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.experimentalH3ToLocalIj(evalThis[0].origin, evalThis[0].destination)));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].local_ij = h3.experimentalH3ToLocalIj(evalThis[i].origin, evalThis[i].destination);
};')

  if(simple == TRUE) {
    out <- sesh$get('evalThis')
    as.matrix(out$local_ij)
  } else {
    out <- sesh$get('evalThis')
    out <- cbind('origin' = out$origin,
                 'destination' = out$destination,
                 out$local_ij)
    out <- sf::st_as_sf(out, coords = c('i', 'j'))
    out
  }

  }

#' Get H3 address from local i, j coordinates
#'
#' This function returns H3 destination addresses for local i, j coordinate
#' pairs anchored by an H3 origin address.
#' @param origin Character; 15-character address generated by H3. A vector of
#'   addresses can also be supplied.
#' @param coords List with 2 integer elements; a single i coordinate or vector
#'   of same, and a single j coordinate or vector of same. List elements must
#'   have the same length.
#' @param simple Logical; whether to return a vector of outputs or a data frame
#'   containing both inputs and outputs.
#' @return If `simple = TRUE`, a character vector of H3 addresses. If not, a
#'   data frame containing columns origin, i, j, destination.
#' @note
#' \itemize{
#'   \item{The coordinate space used by this function may have deleted regions
#'   or warping due to pentagonal distortion.}
#'   \item{Coordinates are only comparable if they come from the same origin
#'   index.}
#'   \item{Failure may occur if the index is too far away from the origin or if
#'   the index is on the other side of a pentagon.}
#'   \item{This function is experimental, and its output is not guaranteed to be
#'   compatible across different versions of H3.}
#'  }
#' @examples
#' # Get local coordinates for a nearby hexagon
#' local <- get_local_ij(origin = '86be8d12fffffff', destination = '86be8d127ffffff')
#'
#' # Convert back to destination address
#' get_local_h3(origin = local$origin, coords = list(local$local_i, local$local_j))
#'
#' @import V8
#' @export
#'
get_local_h3 <- function(origin = NULL, coords = NULL, simple = TRUE) {

  if(any(is_valid(origin)) == FALSE) {
    stop('Invalid H3 address detected.')
  }

  if(any(is.null(origin))) {
    stop('Missing required input.')
  }

  if(!is.list(coords)) {
    stop('Please supply coordinates as a two-element list with elements of equal length.')
  }

  # I hate this whole approach, revise later
  sesh$assign('evalThis', data.frame(origin,
                                     'local_i' = coords[[1]],
                                     'local_j' = coords[[2]],
                                     stringsAsFactors = FALSE))

  # for debug:
  # sesh$eval('console.log(JSON.stringify(evalThis[0]))')
  # sesh$eval('console.log(JSON.stringify(h3.experimentalLocalIjToH3(evalThis[0].origin, {i:evalThis[0].local_i, j:evalThis[0].local_j})));')
  sesh$eval('for (var i = 0; i < evalThis.length; i++) {
            evalThis[i].destination = h3.experimentalLocalIjToH3(evalThis[i].origin, {i:evalThis[i].local_i, j:evalThis[i].local_j});
};')

  if(simple == TRUE) {
    sesh$get('evalThis')$destination
  } else {
    sesh$get('evalThis')
  }

  }

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/custom_functions.R
\name{nearest_neighbour}
\alias{nearest_neighbour}
\title{Use H3 to find nearest neighbours}
\usage{
nearest_neighbour(locations = NULL, res = NULL)
}
\arguments{
\item{locations}{sf POINT data frame with >1 rows.}

\item{res}{Integer; Desired H3 resolution. See
https://uber.github.io/h3/#/documentation/core-library/resolution-table for
allowable values and related dimensions.}
}
\value{
The input object with duplicated columns holding nearest neighbour
  attributes, along with a distance column and a secondary geometry column
  containing the nearest neighbour location. The additional columns
  are signified with naming convention '*_nn'.
}
\description{
This function finds the nearest neighbour for a given set of spatial points.
}
\note{
The true nearest neighbour for any point should always be one of the
  points with the shortest \code{\link[h3jsr:grid_distance]{grid_distance}}
  from the origin, or at most, grid_distance + 2 if the origin is close to a
  hex boundary. Where more than one point is a candidate for nearest
  neighbour, \code{\link[sf:st_distance]{st_distance}} is used to pick the
  closest point, so results may not be truly accurate unless the input
  dataset has been projected using an appropriate distance-preserving
  coordinate transformation. This function will probably not be accurate at
  continental scales.
}
\examples{
\dontrun{
# Find the nearest neighbours for spData::cycle_hire()
data(cycle_hire, package = 'spData')
# UTM projection should give accurate enough distances at this extent
cycle_hire <- sf::st_transform(cycle_hire, 32630)
# ~10 seconds on a mid-range 2018 laptop:
cycle_hire_nn <- nearest_neighbour(locations = cycle_hire, res = 11)

# check results against spatstat::nncross(), which incidentally is a lot
faster...
st_as_ppp <- function(x = NULL) {
  ecks <- sapply(seq.int(length(x$geometry)), function(y) {
    x$geometry[[y]][1]
  })
  why <- sapply(seq.int(length(x$geometry)), function(y) {
    x$geometry[[y]][2]
  })
  o_win <- spatstat::owin(range(ecks), range(why))
  spatstat::ppp(ecks, why, window = o_win)
}

cycle_ppp     <- st_as_ppp(cycle_hire)
cycle_nncross <- spatstat::nncross(cycle_ppp, cycle_ppp, k = 2)

# above says point #1's nearest neighbour is the point at row 167
cycle_hire_nn$geometry_nn[[1]] == cycle_hire_nn$geometry[[167]]

# and that they're ~200m apart
cycle_hire_nn$distance_nn[1]
cycle_nncross$dist.2[1]
}

}

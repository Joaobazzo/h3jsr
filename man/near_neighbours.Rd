% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/custom_functions.R
\name{near_neighbours}
\alias{near_neighbours}
\title{Use H3 to find nearest neighbours}
\usage{
near_neighbours(locations = NULL, res = NULL)
}
\arguments{
\item{locations}{sf POINT data frame with >1 rows.}

\item{res}{Integer; Desired H3 resolution. See
https://uber.github.io/h3/#/documentation/core-library/resolution-table for
allowable values and related dimensions.}
}
\value{
The input object, with the addition of a secondary geometry column
  containing the nearest neighbouring point.
}
\description{
This function finds nearest neighbours among a set of spatial points.
}
\note{
The true nearest neighbour for any
  point should always be one of the points with the shortest
  \code{\link[h3jsr:grid_distance]{grid_distance}} from the origin, or at
  most, grid_distance + 2 if the origin is close to a hex boundary. Where
  more than one point is a candidate for nearest neighbour,
  \code{\link[sf:st_distance]{st_distance}} is used to pick the closest
  point, so results may not be truly accurate unless the input dataset has
  been projected using an appropriate distance-preserving coordinate
  transformation. This function will probably not be accurate at continental
  scales.
}
\examples{
\dontrun{
# Find the nearest neighbours for spData::cycle_hire()
data(cycle_hire, package = 'spData')
# UTM projection should give accurate enough distances at this extent
cycle_hire <- sf::st_transform(cycle_hire, 32630)
# ~10 seconds on a mid-range 2018 laptop:
cycle_hire <- near_neighbours(locations = cycle_hire, res = 11)

# check results against spatstat::nncross(), which incidentally is a lot
faster...
st_as_ppp <- function(x = NULL) {
  ecks <- sapply(seq.int(length(x$geometry)), function(y) {
    x$geometry[[y]][1]
  })
  why <- sapply(seq.int(length(x$geometry)), function(y) {
    x$geometry[[y]][2]
  })
  o_win <- spatstat::owin(range(ecks), range(why))
  spatstat::ppp(ecks, why, window = o_win)
}

cycle_ppp <- st_as_ppp(cycle_hire)
cycle_nncross <- spatstat::nncross(cycle_ppp, cycle_ppp, k = 2)
# above says point #1's nearest neighbour is point #167
cycle_hire$nn_geom[[1]] == cycle_hire$geometry[[167]]
# and that they're ~200m apart
sf::st_distance(cycle_hire[1,], cycle_hire[167, ])
cycle_nncross$dist.2[1]
}

}
